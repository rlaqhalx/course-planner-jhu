import {
  require_extends
} from "./chunk-6KB7OQ57.js";
import {
  require_interopRequireDefault
} from "./chunk-RV3SY6RA.js";
import {
  esm_exports,
  init_esm
} from "./chunk-A5X2FJ4M.js";
import "./chunk-QV4XRCI3.js";
import "./chunk-M45RNPIH.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-J43GMYXM.js";

// node_modules/@mui/material/styles/cssUtils.js
var require_cssUtils = __commonJS({
  "node_modules/@mui/material/styles/cssUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.alignProperty = alignProperty;
    exports.convertLength = convertLength;
    exports.fontGrid = fontGrid;
    exports.getUnit = getUnit;
    exports.isUnitless = isUnitless;
    exports.responsiveProperty = responsiveProperty;
    exports.toUnitless = toUnitless;
    function isUnitless(value) {
      return String(parseFloat(value)).length === String(value).length;
    }
    function getUnit(input) {
      return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
    }
    function toUnitless(length) {
      return parseFloat(length);
    }
    function convertLength(baseFontSize) {
      return (length, toUnit) => {
        const fromUnit = getUnit(length);
        if (fromUnit === toUnit) {
          return length;
        }
        let pxLength = toUnitless(length);
        if (fromUnit !== "px") {
          if (fromUnit === "em") {
            pxLength = toUnitless(length) * toUnitless(baseFontSize);
          } else if (fromUnit === "rem") {
            pxLength = toUnitless(length) * toUnitless(baseFontSize);
          }
        }
        let outputLength = pxLength;
        if (toUnit !== "px") {
          if (toUnit === "em") {
            outputLength = pxLength / toUnitless(baseFontSize);
          } else if (toUnit === "rem") {
            outputLength = pxLength / toUnitless(baseFontSize);
          } else {
            return length;
          }
        }
        return parseFloat(outputLength.toFixed(5)) + toUnit;
      };
    }
    function alignProperty({
      size,
      grid
    }) {
      const sizeBelow = size - size % grid;
      const sizeAbove = sizeBelow + grid;
      return size - sizeBelow < sizeAbove - size ? sizeBelow : sizeAbove;
    }
    function fontGrid({
      lineHeight,
      pixels,
      htmlFontSize
    }) {
      return pixels / (lineHeight * htmlFontSize);
    }
    function responsiveProperty({
      cssProperty,
      min,
      max,
      unit = "rem",
      breakpoints = [600, 900, 1200],
      transform = null
    }) {
      const output = {
        [cssProperty]: `${min}${unit}`
      };
      const factor = (max - min) / breakpoints[breakpoints.length - 1];
      breakpoints.forEach((breakpoint) => {
        let value = min + factor * breakpoint;
        if (transform !== null) {
          value = transform(value);
        }
        output[`@media (min-width:${breakpoint}px)`] = {
          [cssProperty]: `${Math.round(value * 1e4) / 1e4}${unit}`
        };
      });
      return output;
    }
  }
});

// node_modules/@mui/material/styles/responsiveFontSizes.js
var require_responsiveFontSizes = __commonJS({
  "node_modules/@mui/material/styles/responsiveFontSizes.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = responsiveFontSizes;
    var _extends2 = _interopRequireDefault(require_extends());
    var _utils = (init_esm(), __toCommonJS(esm_exports));
    var _cssUtils = require_cssUtils();
    function responsiveFontSizes(themeInput, options = {}) {
      const {
        breakpoints = ["sm", "md", "lg"],
        disableAlign = false,
        factor = 2,
        variants = ["h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "caption", "button", "overline"]
      } = options;
      const theme = (0, _extends2.default)({}, themeInput);
      theme.typography = (0, _extends2.default)({}, theme.typography);
      const typography = theme.typography;
      const convert = (0, _cssUtils.convertLength)(typography.htmlFontSize);
      const breakpointValues = breakpoints.map((x) => theme.breakpoints.values[x]);
      variants.forEach((variant) => {
        const style = typography[variant];
        const remFontSize = parseFloat(convert(style.fontSize, "rem"));
        if (remFontSize <= 1) {
          return;
        }
        const maxFontSize = remFontSize;
        const minFontSize = 1 + (maxFontSize - 1) / factor;
        let {
          lineHeight
        } = style;
        if (!(0, _cssUtils.isUnitless)(lineHeight) && !disableAlign) {
          throw new Error(true ? `MUI: Unsupported non-unitless line height with grid alignment.
Use unitless line heights instead.` : (0, _utils.formatMuiErrorMessage)(6));
        }
        if (!(0, _cssUtils.isUnitless)(lineHeight)) {
          lineHeight = parseFloat(convert(lineHeight, "rem")) / parseFloat(remFontSize);
        }
        let transform = null;
        if (!disableAlign) {
          transform = (value) => (0, _cssUtils.alignProperty)({
            size: value,
            grid: (0, _cssUtils.fontGrid)({
              pixels: 4,
              lineHeight,
              htmlFontSize: typography.htmlFontSize
            })
          });
        }
        typography[variant] = (0, _extends2.default)({}, style, (0, _cssUtils.responsiveProperty)({
          cssProperty: "fontSize",
          min: minFontSize,
          max: maxFontSize,
          unit: "rem",
          breakpoints: breakpointValues,
          transform
        }));
      });
      return theme;
    }
  }
});

// dep:@mui_material_styles_responsiveFontSizes
var mui_material_styles_responsiveFontSizes_default = require_responsiveFontSizes();
export {
  mui_material_styles_responsiveFontSizes_default as default
};
//# sourceMappingURL=@mui_material_styles_responsiveFontSizes.js.map
